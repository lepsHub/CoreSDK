name: Cut Release

on:
  pull_request:
    types: [closed]
    branches:
      - 'release/*'
  workflow_dispatch:
    inputs:
      cut:
        description: "Release type"
        type: choice
        options: [beta, rc, prod]
        required: false
      frameworks:
        description: "Which SDK(s) to cut"
        type: choice
        options: [camera, core, all]
        required: false
      dry_run:
        description: "Preview only (no tag/release)"
        type: boolean
        default: false
        required: false

permissions:
  contents: write
  pull-requests: read

concurrency:
  group: cut-release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  cut_release:
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true) ||
      (github.event_name == 'workflow_dispatch')
    runs-on: macos-15

    env:
      LBL_BETA: cut-beta
      LBL_RC: cut-rc

      LBL_CAM: CameraSDK
      LBL_CORE: CoreSDK

      TAGPFX_CAM: 'CameraSDK'
      TAGPFX_CORE: 'CoreSDK'

      CHANNEL_PLIST_KEY: 'TRVReleaseChannel'

      GH_TOKEN: ${{ github.token }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Tooling / Git identity
        run: |
          brew update >/dev/null
          brew install jq xcodegen >/dev/null || true
          git config user.name  "truvideo[bot]"
          git config user.email "truvideo[bot]@users.noreply.github.com"

      - name: Resolve cut type and frameworks (manual > labels > paths)
        id: scope
        shell: bash
        run: |
          set -eo pipefail
          labels="$(jq -r '.pull_request.labels[].name // empty' <<< "${{ toJson(github.event) }}" 2>/dev/null || true)"

          # --- CUT TYPE: prod only manual; beta/rc manual or labels ---
          cut=""
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.cut }}" ]; then
            cut="${{ github.event.inputs.cut }}"
          else
            has_beta=false
            has_rc=false
            grep -qx "${{ env.LBL_BETA }}" <<< "$labels" && has_beta=true
            grep -qx "${{ env.LBL_RC }}" <<< "$labels" && has_rc=true

            if [ "$has_beta" = true ] && [ "$has_rc" = true ]; then
              cut="beta,rc"
            elif [ "$has_beta" = true ]; then
              cut="beta"
            elif [ "$has_rc" = true ]; then
              cut="rc"
            fi
          fi
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            if [ -z "$cut" ] || [ "$cut" = "prod" ]; then
              echo "cut=" >> $GITHUB_OUTPUT; exit 0
            fi
          fi
          if [ -z "$cut" ]; then echo "cut=" >> $GITHUB_OUTPUT; exit 0; fi          
          allow=""
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.frameworks }}" ]; then
            case "${{ github.event.inputs.frameworks }}" in
              camera) allow="cam" ;;
              core)   allow="core" ;;
              all)    allow="cam core" ;;
            esac
          else
            grep -qx "${{ env.LBL_CAM }}"  <<< "$labels" && allow="${allow} cam"  || true
            grep -qx "${{ env.LBL_CORE }}" <<< "$labels" && allow="${allow} core" || true
            allow="$(echo "$allow" | xargs)"
          fi

          final="$allow"; final="$(echo "$final" | xargs)"

          echo "cut=$cut" >> $GITHUB_OUTPUT
          echo "aff=$final" >> $GITHUB_OUTPUT
          echo "dry=${{ github.event.inputs.dry_run }}" >> $GITHUB_OUTPUT

      - name: Generate Xcode project
        if: ${{ steps.scope.outputs.aff != '' }}
        run: |
          set -eo pipefail
          make genbuild
          if [ -f "CoreSDK.xcodeproj/project.pbxproj" ]; then
            proj="CoreSDK.xcodeproj"
          else
            proj=$(ls -1 *.xcodeproj 2>/dev/null | head -n1 || true)
          fi
          if [ -z "$proj" ]; then
            echo "No .xcodeproj found after make genbuild"; exit 1
          fi
          echo "PROJECT=$proj" >> $GITHUB_ENV
          echo "Using PROJECT=$proj"

      - name: Compute versions, update Info.plist, generate Version.swift, tag & release
        if: ${{ steps.scope.outputs.cut != '' && steps.scope.outputs.aff != '' }}
        shell: bash
        run: |
          set -euo pipefail
          set -x
          trap 'echo "âŒ Error at line $LINENO: $BASH_COMMAND"' ERR

          cut="${{ steps.scope.outputs.cut }}"
          dry="${{ steps.scope.outputs.dry }}"

          find_plists () { git ls-files "$1" | grep -E '/Info\.plist$' || true; }
          read_short_ver () { /usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$1" 2>/dev/null || true; }
          write_short_ver () { /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $2" "$1" || /usr/libexec/PlistBuddy -c "Add :CFBundleShortVersionString string $2" "$1"; }
          write_build_num () { /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $2" "$1" || /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $2" "$1"; }
          write_channel_key () {
            local plist="$1" val="$2" key="${{ env.CHANNEL_PLIST_KEY }}"
            /usr/libexec/PlistBuddy -c "Set :$key $val" "$plist" \
              || /usr/libexec/PlistBuddy -c "Add :$key string $val" "$plist"
          }

          bump_from_commits () {
            local last_prod="$1" range="$2" bump="patch"
            if git log --format=%B $range | grep -Eq 'BREAKING CHANGE|!:'; then bump="major"
            elif git log --format=%s $range | grep -Eq '^feat(\(|:)|^feat!'; then bump="minor"
            elif git log --format=%s $range | grep -Eq '^fix(\(|:)|^fix!|^perf(\(|:)|^perf!'; then bump="patch"
            else bump="patch"; fi
            if [ -z "$last_prod" ]; then echo "0.1.0"; return; fi
            base="${last_prod##*-}"
            IFS='.' read -r major minor patch <<< "$base"
            case "$bump" in
              major) major=$((major+1)); minor=0; patch=0 ;;
              minor) minor=$((minor+1)); patch=0 ;;
              patch) patch=$((patch+1)) ;;
            esac
            echo "${major}.${minor}.${patch}"
          }

          next_beta_n () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <(git tag -l "${prefix}-${base}-BETA.*")
            echo $((max+1))
          }

          last_beta_n () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <(git tag -l "${prefix}-${base}-BETA.*")
            echo "$max"
          }

          next_rc_n () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <(git tag -l "${prefix}-${base}-RC.*")
            echo $((max+1))
          }

          last_rc_n () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <(git tag -l "${prefix}-${base}-RC.*")
            echo "$max"
          }

          rc_build_for_base () {
            local prefix="$1" base="$2"
            local bmax rmax
            bmax="$(last_beta_n "$prefix" "$base")"
            rmax="$(last_rc_n  "$prefix" "$base")"
            [ "$bmax" -ge "$rmax" ] && echo $((bmax + 1)) || echo $((rmax + 1))
          }

          latest_build_for_base () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <( { git tag -l "${prefix}-${base}-BETA.*"; git tag -l "${prefix}-${base}-RC.*"; } )
            echo "$max"
          }
          
          next_global_build_number() {
            local prefix="$1" base="$2" max=0
            while read -r t; do
              [ -z "$t" ] && continue
              n="${t##*.}"
              [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n"
            done < <(
              git tag -l "${prefix}-${base}-BETA.*"
              git tag -l "${prefix}-${base}-RC.*"
            )
            echo $((max + 1))
          }

          gen_version_swift () {
            local destdir="$1" full="$2" channel="$3" build="$4"
            mkdir -p "$destdir"
            cat > "$destdir/Version.swift" <<SWIFT
          // Generated by CI â€“ do not edit.
          public let SDKVersionNumber: String = "$full"
          public let SDKEnvironment:   String = "$channel"
          public let SDKBuildNumber:   String = "$build"
          SWIFT
          }

          gen_changelog_md () {
            local range="$1" path="$2"
            local feats="" fixes="" perfs="" refacs="" docs="" tests="" build="" ci="" chores="" breaks=""
            while IFS= read -r s; do
              [ -z "$s" ] && continue
              [[ "$s" =~ BREAKING\ CHANGE|!\: ]] && breaks="${breaks}"$'\n- '"$s"
              if   [[ "$s" =~ ^feat(\(|:|\!) ]];      then feats="${feats}"$'\n- '"$s"
              elif [[ "$s" =~ ^fix(\(|:|\!) ]];       then fixes="${fixes}"$'\n- '"$s"
              elif [[ "$s" =~ ^perf(\(|:|\!) ]];      then perfs="${perfs}"$'\n- '"$s"
              elif [[ "$s" =~ ^refactor(\(|:|\!) ]];  then refacs="${refacs}"$'\n- '"$s"
              elif [[ "$s" =~ ^docs(\(|:|\!) ]];      then docs="${docs}"$'\n- '"$s"
              elif [[ "$s" =~ ^test(\(|:|\!) ]];      then tests="${tests}"$'\n- '"$s"
              elif [[ "$s" =~ ^build(\(|:|\!) ]];     then build="${build}"$'\n- '"$s"
              elif [[ "$s" =~ ^ci(\(|:|\!) ]];        then ci="${ci}"$'\n- '"$s"
              elif [[ "$s" =~ ^chore(\(|:|\!) ]];     then chores="${chores}"$'\n- '"$s"
              fi
            done < <(git log --pretty=format:'%s' $range -- "$path" || true)
            {
              echo "## Changes"
              [ -n "$breaks" ] && { echo; echo "### âš ï¸ Breaking Changes"; echo "$breaks"; }
              [ -n "$feats"  ] && { echo; echo "### âœ¨ Features";        echo "$feats"; }
              [ -n "$fixes"  ] && { echo; echo "### ðŸ› Fixes";           echo "$fixes"; }
              [ -n "$perfs"  ] && { echo; echo "### ðŸš€ Performance";     echo "$perfs"; }
              [ -n "$refacs" ] && { echo; echo "### ðŸ§¹ Refactors";       echo "$refacs"; }
              [ -n "$docs"   ] && { echo; echo "### ðŸ“ Docs";            echo "$docs"; }
              [ -n "$tests"  ] && { echo; echo "### âœ… Tests";           echo "$tests"; }
              [ -n "$build"  ] && { echo; echo "### ðŸ§± Build";           echo "$build"; }
              [ -n "$ci"     ] && { echo; echo "### âš™ï¸ CI";              echo "$ci"; }
              [ -n "$chores" ] && { echo; echo "### ðŸ§° Chore";           echo "$chores"; }
            } | sed '/^$/N;/^\n$/D' || true
          }

          cut_for () {
            local key="$1" cut_type="$2" prefix path vdir channel full base_ver build_num prerelease title
            
            # Framework configuration - easily extensible
            # Format: "key:prefix:path:vdir"
            case "$key" in
              "cam")
                prefix="${{ env.TAGPFX_CAM }}"
                path="Libraries/Plugins/Camera/"
                vdir="Sources/CameraSDK/Generated"
                ;;
              "core")
                prefix="${{ env.TAGPFX_CORE }}"
                path="Libraries/External/Extended/App/"
                vdir="Sources/CoreSDK/Generated"
                ;;
              *)
                echo "Error: Unknown framework key '$key'"
                echo "Available keys: cam, core"
                exit 1
                ;;
            esac

            # Only consider final prod tags for base version
            last_prod=$(
              git tag -l "${prefix}-*" --sort=-v:refname \
              | grep -E "^${prefix}-[0-9]+\.[0-9]+\.[0-9]+$" \
              | head -n1
            )

            since_ref=""; [ -n "$last_prod" ] && since_ref="$(git rev-list -n1 "$last_prod")"
            range="${since_ref:+${since_ref}..}HEAD"

            base_ver="$(bump_from_commits "$last_prod" "${range:-HEAD}")"

            if [ "$cut_type" = "beta" ]; then
              channel="BETA"
              build_num="$(next_global_build_number "$prefix" "$base_ver")"
              full="${base_ver}-BETA.${build_num}"
              prerelease="true"
              title="Internal BETA release for **$prefix $base_ver**."
            elif [ "$cut_type" = "rc" ]; then
              channel="RC"
              build_num="$(next_global_build_number "$prefix" "$base_ver")"
              full="${base_ver}-RC.${build_num}"
              prerelease="true"
              title="Release Candidate for **$prefix $base_ver**."
            else
              channel="PROD"
              full="${base_ver}"
              bn="$(next_global_build_number "$prefix" "$base_ver")"
              [ "$bn" -gt 0 ] && build_num="$bn" || build_num="1"
              prerelease="false"
              title="Production release for **$prefix $base_ver**."
            fi
            
            while read -r plist; do
              [ -z "$plist" ] && continue
              cur_short="$(read_short_ver "$plist")"
              if [ "$cur_short" != "$base_ver" ]; then write_short_ver "$plist" "$base_ver"; fi
              write_build_num "$plist" "$build_num"
              write_channel_key "$plist" "$channel"
            done < <(find_plists "$path")
            
            gen_version_swift "$vdir" "$full" "$channel" "$build_num"

            # Changelog body (since last prod)
            chg="$(gen_changelog_md "$range" "$path")"

            body_header=$(printf '%s\n' \
              "%TITLE%" \
              "" \
              "- **CFBundleShortVersionString**: %BASE%" \
              "- **CFBundleVersion**: %BUILD%" \
              "- **SdkVersionNumber**: %FULL%" \
              "- **Channel**: %CHANNEL%" \
              "" \
              "%CHANGELOG%")
            body="${body_header//%TITLE%/$title}"
            body="${body//%BASE%/$base_ver}"
            body="${body//%BUILD%/$build_num}"
            body="${body//%FULL%/$full}"
            body="${body//%CHANNEL%/$channel}"
            body="${body//%CHANGELOG%/$chg}"

            tag="${prefix}-${full}"

            if [ "$dry" = "true" ]; then
              echo "[DRY RUN] Would tag: $tag"
              echo "[DRY RUN] Would create release:"; echo "$body"
              return 0
            fi            
            git add "$path" || true
            if [ -f "$vdir/Version.swift" ] && ! git check-ignore -q "$vdir/Version.swift"; then
              git add "$vdir/Version.swift"
            fi
            if ! git diff --cached --quiet; then
              git commit -m "chore(release): bump ${prefix} to ${full} (${channel})"
            fi

            git tag -a "$tag" -m "$title"
            git push origin "refs/tags/${tag}"
          }

          for s in ${{ steps.scope.outputs.aff }}; do
            for cut_type in $(echo "${{ steps.scope.outputs.cut }}" | tr ',' ' '); do
              cut_for "$s" "$cut_type"
            done
          done
